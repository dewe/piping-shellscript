#!/bin/sh
set -eu

usage() {
    cat >&2 << 'EOF'
Usage: transpose

Transpose lines of text from stdin to stdout.
Converts rows to columns - characters at the same position
in each line become a new line.

Examples:
  echo "hello" | transpose
  transpose < input.txt
  cat file1 file2 | transpose
EOF
}

main() {
    if [ $# -gt 0 ]; then
        case "$1" in
            -h|--help)
                usage
                exit 0
                ;;
        esac
    fi

    if [ -t 0 ]; then
        usage
        exit 1
    fi

    if ! IFS= read -r first_line; then
        exit 0
    fi

    { printf '%s\n' "$first_line"; cat; } | iconv -f UTF-8 -t ASCII//TRANSLIT 2>/dev/null | awk '
    function extract_ansi_codes(line,    prefix, suffix, plain, i, in_escape, c, code) {
        prefix = ""
        suffix = ""
        plain = ""
        i = 1
        in_escape = 0
        code = ""
        found_prefix = 0
        
        while (i <= length(line)) {
            c = substr(line, i, 1)
            
            if (c == "\033") {
                in_escape = 1
                code = c
            } else if (in_escape) {
                code = code c
                if (c == "m") {
                    in_escape = 0
                    
                    if (!found_prefix && code != "\033[0m") {
                        prefix = code
                        found_prefix = 1
                    }
                    if (code == "\033[0m") {
                        suffix = code
                    }
                    code = ""
                }
            } else {
                plain = plain c
            }
            i++
        }
        
        ansi_prefix[line_num] = prefix
        ansi_suffix[line_num] = suffix
        return plain
    }
    
    function collect_chars_at_position(position,    j, plain_text, input_length, char) {
        plain_output = ""
        colors_for_chars = ""
        
        for (j = 1; j <= line_num; j++) {
            plain_text = plain_lines[j]
            input_length = line_lengths[j]
            
            if (position <= input_length) {
                char = substr(plain_text, position, 1)
                plain_output = plain_output char
                colors_for_chars = colors_for_chars j ","
            } else {
                plain_output = plain_output " "
                colors_for_chars = colors_for_chars "0,"
            }
        }
        
        sub(/ +$/, "", plain_output)
        return plain_output
    }
    
    function apply_colors(plain_text, color_mapping,    line, output_len, k, char, source_line, color, suffix, current_color, current_suffix, chars_in_group, color_array) {
        line = ""
        output_len = length(plain_text)
        current_color = ""
        chars_in_group = ""
        
        split(color_mapping, color_array, ",")
        
        for (k = 1; k <= output_len; k++) {
            char = substr(plain_text, k, 1)
            source_line = color_array[k]
            
            if (source_line > 0) {
                color = ansi_prefix[source_line]
                suffix = ansi_suffix[source_line]
            } else {
                color = ""
                suffix = ""
            }
            
            if (color != current_color && chars_in_group != "") {
                if (current_color != "") {
                    line = line current_color chars_in_group current_suffix
                } else {
                    line = line chars_in_group
                }
                chars_in_group = ""
            }
            
            chars_in_group = chars_in_group char
            current_color = color
            current_suffix = suffix
        }
        
        if (chars_in_group != "") {
            if (current_color != "") {
                line = line current_color chars_in_group current_suffix
            } else {
                line = line chars_in_group
            }
        }
        
        return line
    }
    
    {
        line_num++
        input_lines[line_num] = $0
        
        plain_text = extract_ansi_codes($0)
        plain_lines[line_num] = plain_text
        line_length = length(plain_text)
        line_lengths[line_num] = line_length
        
        if (line_length > max_len) {
            max_len = line_length
        }
    }
    
    END {
        for (i = 1; i <= max_len; i++) {
            plain = collect_chars_at_position(i)
            colored = apply_colors(plain, colors_for_chars)
            print colored
        }
    }
    '
}

main "$@"

